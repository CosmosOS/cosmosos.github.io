<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Layout </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Layout ">
    <meta name="generator" content="docfx 2.45.1.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc">
    <meta property="docfx:tocrel" content="../toc">
    
    
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../index.html" title="Home">Home</a>
                      </li>
                      <li>
                          <a href="https://gocosmos.org" title="Cosmos Website">Cosmos Website</a>
                      </li>
                      <li>
                          <a href="../../articles/GettingStarted.html" title="Articles">Articles</a>
                      </li>
                      <li>
                          <a href="../../api/Cosmos.Build.Tasks.html" title="API Documentation">API Documentation</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <a href="../GettingStarted.html" title="Getting Started" class="">Getting Started</a>
                    </li>
                    <li class="">
                      <a href="../Compiler/il2cpu.html" title="Compiler" class="">Compiler</a>
                    </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Debugger</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="../Debugger/DebugCommands.html" title="Debug Commands" class="">Debug Commands</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <a href="../Express/Compile.html" title="Express" class="">Express</a>
                    </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Installation</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="../Installation/DevKit.html" title="Dev Kit" class="">Dev Kit</a>
                          </li>
                          <li class="">
                            <a href="../Installation/Running.html" title="Running" class="">Running</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Kernel</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="../Kernel/Heap.html" title="Heap" class="">Heap</a>
                          </li>
                          <li class="">
                            <a href="../Kernel/Levels.html" title="Levels" class="">Levels</a>
                          </li>
                          <li class="active">
                            <a href="../Kernel/Memory.html" title="Memory" class="active">Memory</a>
                          </li>
                          <li class="">
                            <a href="../Kernel/Plugs.html" title="Plugs" class="">Plugs</a>
                          </li>
                          <li class="">
                            <a href="../Kernel/Startup.html" title="Startup" class="">Startup</a>
                          </li>
                          <li class="">
                            <a href="../Kernel/CGS.html" title="Graphics" class="">Graphics</a>
                          </li>
                          <li class="">
                            <a href="../Kernel/VFS.html" title="Virtual File System" class="">Virtual File System</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Reference</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="../Reference/x86.html" title="x86" class="">x86</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Tests</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="../Tests/TestRunner.html" title="Test Runner" class="">Test Runner</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="layout">Layout</h1>

<pre><code>Top of Ram (F..F in a full system)

Stack
  Currently only one stack as we don't have threads yet.
  Stack resides at top of RAM and grows down. 
  In future each process will have its own stack in DATA. 
  And Stack master section will be eliminated.
  Because of this we currently treat the stack as a fixed size so the heap has a fixed top.
  In the future everything will be movable and thus individual stacks could even be moved, grown, or shrunk.
....

Data
  ALL items in data *must be movable* to allow very long up times of the system.
  Can relocate by moving page with in virtmem and changing refs.
  -Heap: Global heap for all processes since compiler enforces references.
  -Stacks (future)
  -Code (Future)
  -Disk Cache (Future)
  -RAT
  -All single blocks go on bottom, multi page blocks on top. Will help reduce fragmentation greatly.

Text
  All sections are fixed in size and are stacked.
  -Syslinux Boot Code
  -Cosmos Boot Code
  -Kernel
  -Apps (Monolithic currently, will move to DATA later)
  -Legacy GDT
  -IDT
  -Page Tables

0..0
</code></pre>
<h3 id="notes">Notes</h3>
<pre><code>TODO
-Get some heap statistics, average size etc

Heap Containers
All meta data is identical and inline with data. Exists before handle pointer. Keeping
inline increases block size, but makes it faster to find metadata and keeps it uniform.
Could have a single pointer to another record elsewhere, but increases complexity and does not provide
major benefit.
-Data (handle pointer points here)
-32/64 Ptr to first ref
using 32 below saves space on small/med objects. slightly increases access time, but access to these fields is not time critical
-32 (64 to align on large) Ref count
-32 (64 for large) Size (always need, cant interpolate even from slotted as may be smaller than slot)
  -Always allocate bigger to word align (or page align for large?). Wont bother .NET, it never needs size from heap.
  -If need align - could add 3 and mask lower 2 bits to round up.
-Optional
  -32/64 Size allocated - may be bigger and not needed for slotted etc.

-Tiny 
If needed can make tiny types too with only ref and ptr, no need for size. But check heap and
see if such small ones are common. Probably not, likely only for boxing etc.

-Small (Tables)
Fixed sizes, max size one page. 
Keeping to one page maximizes movability.
MetaData integrated into page.
Page allocated at bottom (as with all single page items)

-Medium (Stacked)
Contains items end to end in a linked list.
Metadata storage? Prob external at bottom
Could span mult pages, but better if kept in single ones for movability. 
Faster compacting as well. 
Or at least define a default size which is a group of pages.

-Large (Single)
For large items that are close to page size or larger
Metadata is grouped from mult containers into one table to avoid excessive rewriting of references
and easy scanning of all items in system.
Could group metadata by process in future, or sort table from time to time?
Use linked list of single page tables in bottom and each item has a link back to the table so compacting is easy
Item
-Handle points directly to data

Heap Index
-Sections containing entries which
  -Point to first ref
  -Ref count
  -Other metadata about item in heap
  -Table also contains specific info about the page, largest free, smallest free, etc.
  Info could be on a delayed update

Heap pages come in several types
-Slotted - predefined sizes. 64, 256 etc... anything that sizes or smaller goes in a table
-Stacked - ie end to end wtih markers. 
-Single - large ones.. items bigger than a page. Possibly same as stacked, but with only one item. and a handle
from a grouped table rather than one table for the page.

Guest OSes can grow or release RAM as needed to host.

Allocate small and medium containers on bottom, large on top for distribution and easier reuse.

Heap items can grow by adding pages, extending size, or expanding into the slot.

DATA less likely to fragment much becuase the various container sizes aggregate and collect smaller items
together.

Code can be relocated and even split into various blocks.

Is portable and simple. Can even be used without VirtMem, but increases time during page moves.
</code></pre>
<pre><code>MM API
+Allocate new item
-Add/remove ref
-Lock/unlock an item
-Force a compact
-Resize a heap item - now way to integrate .NET as it doesnt resize ever (copies instead), but may be useful internally.
Could also plug stringbuilder resize, etc. Possibly even special strings when used internally?

Implicit
+Get pointer

Internal
-Compact
-Relocate items

Properties
-Ref count
-Lock status
-Size

Handles
-Use indirect pointers via a lookup table. Handle is ptr to table. Global table to save space.
  -No way to compact tables? 
  -use linked list of tables to allow some compaction? 
  -Allocate tables to processes so they will go away 100% when process goes way since its not fully shrinkable.
  -Keep in data space in future?
  -Small tables increase compaction opportunities
-Points to actual data
-Properties are before pointer
-In atomic ops (IL emit groups) - pointer can be grabbed and stored
</code></pre>
<h1 id="old-below-this-point">OLD BELOW THIS POINT</h1>
<p>On initialization of the kernel, a GlobalInformationTable is setup. This contains the address of the first DataLookupEntry</p>
<h1 id="the-memory-manager">The Memory Manager</h1>
<p>The manager will init itself if there are no blocks. The manager is modeled after a double LinkedList and is not a List.</p>
<h1 id="memory-layout">Memory Layout</h1>
<p>The layout does  not have a preset list or table but rather every item has meta data linking the next and previous item. This allows for a robust system.</p>
<p>The data layout is as follows:</p>
<pre><code>Block|Block|Block etc.

Block =

Meta Data|Data

Meta data =
4 bytes (preveus block address start)|4 bytes (next block address start)|4 bytes (curent[this] block size)| 4 bytes (curent[this] block flag)
```
BlockFlags :

```
Allocated = 0,
Free = 1,
```

the final layout looks like this:

```
4 bytes|4 bytes|4 bytes|4 bytes | (size of Block) bytes  |  4 bytes|4 bytes|4 bytes | 4 bytes | (size of Block) bytes  | etc

```
Note:
this means the smallest size an Block can occupy is 17 bytes, 16 bytes for the header and 1 for the smallest data type a byte.

# Usage

### Allocation
  Allocating a block happens by finding the first free block and split it (if necessary).

## Deallocation
  Freeing a block is easy set its flag (in the metadata) to free.
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/CosmosOS/Cosmos/blob/02579c11de5db5e4e7a507902da2f816857630c4/Docs/articles/Kernel/Memory.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span></span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
